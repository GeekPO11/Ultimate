//
//  UltimateApp.swift
//  Ultimate
//
//  Created by Sanchay Gumber on 2/28/25.
//

import SwiftUI
import SwiftData
import UserNotifications

@main
struct UltimateApp: App {
    @StateObject private var userSettings = UserSettings()
    @StateObject private var notificationManager: NotificationManager = NotificationManager.shared
    @AppStorage("hasCompletedOnboarding") private var hasCompletedOnboarding = false
    @Environment(\.scenePhase) private var scenePhase
    @State private var modelContainer: ModelContainer?
    @StateObject private var dataMigrationService = DataMigrationService.shared
    @State private var hasRequestedNotificationPermission = false
    
    // Define model types statically to avoid type inference
    private static let modelTypes: [any PersistentModel.Type] = [
        Challenge.self,
        Task.self,
        DailyTask.self,
        ProgressPhoto.self,
        User.self
    ]
    
    init() {
        print("UltimateApp: Initializing...")
        
        // Set up notification delegate
        UNUserNotificationCenter.current().delegate = NotificationDelegate.shared
        
        // Reset badge count on launch
        UNUserNotificationCenter.current().setBadgeCount(0)
        
        print("UltimateApp: Initialization complete")
    }
    
    var body: some Scene {
        WindowGroup {
            if modelContainer == nil {
                // Show loading view while container is being created
                ProgressView("Setting up...")
                    .onAppear {
                        setupModelContainer()
                    }
            } else if !hasCompletedOnboarding {
                OnboardingView()
                    .modelContainer(modelContainer!)
                    .environmentObject(userSettings)
            } else {
                MainTabView()
                    .modelContainer(modelContainer!)
                    .environmentObject(userSettings)
                    .onAppear {
                        if !hasRequestedNotificationPermission {
                            NotificationManager.shared.requestAuthorization { _ in
                                hasRequestedNotificationPermission = true
                            }
                        }
                    }
                    .onChange(of: dataMigrationService.isMigrationComplete) { _, _ in
                        // Refresh data after migration if needed
                    }
            }
        }
    }
    
    private func setupModelContainer() {
        do {
            // Create a schema with all model types
            let schema = Schema([
                Challenge.self,
                Task.self,
                DailyTask.self,
                ProgressPhoto.self,
                User.self
            ])
            
            // Create a configuration with migration options
            let modelConfiguration = ModelConfiguration(
                schema: schema,
                isStoredInMemoryOnly: false,
                allowsSave: true
            )
            
            // Try to create the container with the configuration
            do {
                let container = try ModelContainer(for: schema, configurations: [modelConfiguration])
                
                // Set up migration handler for the container's context
                let context = container.mainContext
                // Perform migration checks
                dataMigrationService.checkAndPerformMigration(modelContext: context)
                
                // Set the container
                self.modelContainer = container
                Logger.info("Model container created successfully", category: .database)
            } catch {
                // First attempt failed, try to recover
                Logger.error("Failed to create model container: \(error.localizedDescription)", category: .database)
                throw error // Re-throw to be caught by outer catch block
            }
        } catch {
            Logger.error("Failed to create model container: \(error.localizedDescription)", category: .database)
            
            // Try to delete the store and create a new one
            do {
                Logger.warning("Attempting to delete and recreate the persistent store", category: .database)
                // Try to delete the persistent store files manually
                try deletePersistentStore()
                
                // Create a basic container after deleting the store
                let schema = Schema([
                    Challenge.self,
                    Task.self,
                    DailyTask.self,
                    ProgressPhoto.self,
                    User.self
                ])
                
                // Try with a simpler configuration
                let modelConfiguration = ModelConfiguration(
                    schema: schema,
                    isStoredInMemoryOnly: false,
                    allowsSave: true
                )
                
                do {
                    self.modelContainer = try ModelContainer(for: schema, configurations: [modelConfiguration])
                    Logger.info("Created new model container after deleting store", category: .database)
                    
                    // After successful creation, perform migration
                    if let container = self.modelContainer {
                        dataMigrationService.checkAndPerformMigration(modelContext: container.mainContext)
                    }
                } catch {
                    Logger.error("Failed to create model container even after deleting store: \(error.localizedDescription)", category: .database)
                    
                    // Last resort: try in-memory only
                    do {
                        let inMemoryConfig = ModelConfiguration(
                            schema: schema,
                            isStoredInMemoryOnly: true,
                            allowsSave: true
                        )
                        self.modelContainer = try ModelContainer(for: schema, configurations: [inMemoryConfig])
                        Logger.warning("Created in-memory model container as last resort", category: .database)
                    } catch {
                        Logger.error("All attempts to create model container failed: \(error.localizedDescription)", category: .database)
                    }
                }
            } catch {
                Logger.error("Failed to recover from model container creation error: \(error.localizedDescription)", category: .database)
                
                // Last resort: try in-memory only
                do {
                    let schema = Schema([
                        Challenge.self,
                        Task.self,
                        DailyTask.self,
                        ProgressPhoto.self,
                        User.self
                    ])
                    let inMemoryConfig = ModelConfiguration(
                        schema: schema,
                        isStoredInMemoryOnly: true,
                        allowsSave: true
                    )
                    self.modelContainer = try ModelContainer(for: schema, configurations: [inMemoryConfig])
                    Logger.warning("Created in-memory model container as last resort", category: .database)
                } catch {
                    Logger.error("All attempts to create model container failed: \(error.localizedDescription)", category: .database)
                }
            }
        }
    }
    
    // Helper method to delete the persistent store files
    private func deletePersistentStore() throws {
        let fileManager = FileManager.default
        
        // Get all possible locations where SwiftData might store files
        let locations = [
            try fileManager.url(for: .applicationSupportDirectory, in: .userDomainMask, appropriateFor: nil, create: false),
            try fileManager.url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: false),
            try fileManager.url(for: .cachesDirectory, in: .userDomainMask, appropriateFor: nil, create: false)
        ]
        
        var deletedAny = false
        var lastError: Error? = nil
        
        // Check each location for SwiftData stores
        for baseURL in locations {
            // Common SwiftData store names/patterns
            let storePatterns = ["default.store", "*.sqlite", "*.sqlite-shm", "*.sqlite-wal"]
            
            for pattern in storePatterns {
                do {
                    // Find all files matching the pattern
                    let resourceKeys: [URLResourceKey] = [.isDirectoryKey]
                    let directoryEnumerator = fileManager.enumerator(
                        at: baseURL,
                        includingPropertiesForKeys: resourceKeys,
                        options: [.skipsHiddenFiles],
                        errorHandler: nil
                    )
                    
                    guard let enumerator = directoryEnumerator else { continue }
                    
                    for case let fileURL as URL in enumerator {
                        // Check if the file matches our pattern
                        if fileURL.lastPathComponent.contains(pattern.replacingOccurrences(of: "*", with: "")) ||
                           (pattern == "default.store" && fileURL.lastPathComponent == pattern) {
                            do {
                                try fileManager.removeItem(at: fileURL)
                                Logger.info("Deleted SwiftData file: \(fileURL.path)", category: .database)
                                deletedAny = true
                            } catch {
                                Logger.warning("Failed to delete file \(fileURL.path): \(error.localizedDescription)", category: .database)
                                lastError = error
                            }
                        }
                    }
                } catch {
                    Logger.warning("Error enumerating directory \(baseURL.path): \(error.localizedDescription)", category: .database)
                    lastError = error
                }
            }
        }
        
        // If we didn't delete anything and have an error, throw it
        if !deletedAny && lastError != nil {
            throw lastError!
        }
        
        // If we deleted at least one file, consider it a success
        if deletedAny {
            Logger.info("Successfully deleted one or more persistent store files", category: .database)
        } else {
            Logger.warning("No persistent store files found to delete", category: .database)
        }
    }
}

/// Delegate for handling notification responses
class NotificationDelegate: NSObject, UNUserNotificationCenterDelegate {
    static let shared = NotificationDelegate()
    
    private override init() {
        super.init()
    }
    
    /// Called when a notification is received while the app is in the foreground
    func userNotificationCenter(
        _ center: UNUserNotificationCenter,
        willPresent notification: UNNotification,
        withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void
    ) {
        // Show the notification even when the app is in the foreground
        completionHandler([.banner, .sound, .badge])
    }
    
    /// Called when the user responds to a notification
    func userNotificationCenter(
        _ center: UNUserNotificationCenter,
        didReceive response: UNNotificationResponse,
        withCompletionHandler completionHandler: @escaping () -> Void
    ) {
        // Handle the notification response
        NotificationManager.shared.handleNotificationResponse(response, completionHandler: completionHandler)
    }
}
